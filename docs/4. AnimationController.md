# AnimationController

Manages which animation is currently playing for an `Animatable`.

---
## Overview

Stores multiple named animations (each a sequence of frames) and lets you switch between them at runtime.

---
## Fields

- `animations` – Map<String, BufferedImage[]> of animations  
- `currentAnimationName` – The currently active animation

---
## Methods

```java
AnimationController(Animatable animatable, Map<String, BufferedImage[]> animations)
```

Creates a new AnimationController.

- `animatable` – The object being animated  
- `animations` – Map of animation names to arrays of frames

### Example

```java
// The player object must implement Animatable!
Player player = new Player(0, 0); // This is just an example

// Create an AnimationController for the player object
AnimationController playerAnimationController = 
	new AnimationController(player, animations);
```


---

```java
void play(String name)
```

Switches to a new animation by name. This does nothing if the animation is already active

- Does nothing if the animation is already active  
- Prints a warning if the animation does not exist

### Example

```java
// The player object must implement Animatable!
Player player = new Player(0, 0); // This is just an example

// Create an AnimationController for the player object
AnimationController playerAnimationController = 
	new AnimationController(player, animations);
	
// Use the playerAnimationController to play an animation that has been loaded
playerAnimationController.play("IdleNorth");
```


---

```java
BufferedImage[] getCurrentAnimation()
```

Returns the frames of the current animation, or `null` if none is active.

### Example

```java
// The player object must implement Animatable!
Player player = new Player(0, 0); // This is just an example

// Create an AnimationController for the player object
AnimationController playerAnimationController = 
	new AnimationController(player, animations);
	
// Use the playerAnimationController to play an animation that has been loaded
playerAnimationController.play("IdleNorth");

// Now use getCurrentAnimation to retrieve the current frames from the controller
BufferedImage[] playerCurrentFrames = 
	playerAnimationController.getCurrentAnimation();

// Instantiate the animator for playing the frames
Animator playerAnimator = new Animator();
playerAnimator.setFrameDuration(1000); // 1000ms per frame

// Now use the playerCurrentFrames to setup the Animator
playerAnimator.animate(
    playerCurrentFrames,    // The raw frames (from controller)
    true,                   // Loop forever
    player,                 // The entity being animated
    graphics,               // Your Graphics2D context
    0,                      // No camera offset for X
    0,                      // No camera offset for Y
    32                      // Size to render (32px)
);
```


---

```java
boolean isPlaying(String name)
```

Checks if the given animation name is currently active.

### Example

```java
// The player object must implement Animatable!
Player player = new Player(0, 0); // This is just an example

// Create an AnimationController for the player object
AnimationController playerAnimationController = 
	new AnimationController(player, animations);

// Suppose this is called each frame in your game loop:
if (player.isMoving())
{
    // Only switch if not already walking
    if (!playerAnimationController.isPlaying("WalkNorth"))
    {
        playerAnimationController.play("WalkNorth");
    }
}
else
{
    // Only switch if not already idle
    if (!playerAnimationController.isPlaying("IdleNorth"))
    {
        playerAnimationController.play("IdleNorth");
    }
}

// Then later when drawing:
BufferedImage[] currentFrames = playerAnimationController.getCurrentAnimation();
playerAnimator.animate(currentFrames, true, player, graphics, 0, 0, 32);
```

>**Tip: Caching Current Frames**  
>
>`getCurrentAnimation()` is O(1), because it’s just a map lookup. It’s *probably* safe to call every frame in your game loop since it is very fast.
> 
>However, if you prefer, you can also cache the current frames whenever you call `play(...)` and reuse them until the animation changes:
> 
>Both approaches are valid. Calling every frame is simpler, but caching is slightly more explicit.
>
>Example of caching: 
>
```java
if (!playerAnimationController.isPlaying("WalkNorth")) 
{     
	playerAnimationController.play("WalkNorth");     
	cachedFrames = playerAnimationController.getCurrentAnimation(); 
}  

// Then later use cachedFrames directly: 
playerAnimator.animate(cachedFrames, true, player, graphics, 0, 0, 32);
```

---

